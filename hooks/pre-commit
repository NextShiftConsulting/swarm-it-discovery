#!/bin/bash
#
# Pre-commit hook to prevent committing credentials
#

RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "Running credential safety checks..."

# Get list of files to be committed
FILES=$(git diff --cached --name-only --diff-filter=ACM)

if [ -z "$FILES" ]; then
    exit 0
fi

FAILED=0

# =============================================================================
# CHECK 1: Detect common credential patterns in file content
# =============================================================================
echo "Checking for credential patterns..."

PATTERNS=(
    "api[_-]?key['\"]?\s*[:=]"
    "secret[_-]?key['\"]?\s*[:=]"
    "password['\"]?\s*[:=]"
    "token['\"]?\s*[:=].*['\"][a-zA-Z0-9]{20,}"
    "bearer\s+[a-zA-Z0-9\-\._~\+\/]+=*"
    "ssh-rsa\s+AAAA"
    "BEGIN\s+(RSA|DSA|EC|OPENSSH)\s+PRIVATE\s+KEY"
    "-----BEGIN\s+PRIVATE\s+KEY-----"
    "aws_access_key_id"
    "aws_secret_access_key"
    "AKIA[0-9A-Z]{16}"  # AWS Access Key
    "github_pat_[a-zA-Z0-9]{22}_[a-zA-Z0-9]{59}"  # GitHub PAT
    "ghp_[a-zA-Z0-9]{36}"  # GitHub Personal Access Token (classic)
    "gho_[a-zA-Z0-9]{36}"  # GitHub OAuth Token
    "sk-[a-zA-Z0-9]{48}"  # OpenAI API Key
    "hf_[a-zA-Z0-9]{34}"  # Hugging Face Token
    "xoxb-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24}"  # Slack Bot Token
)

for file in $FILES; do
    # Skip binary files and files that don't exist
    if [ ! -f "$file" ] || file "$file" | grep -q "executable\|binary"; then
        continue
    fi

    # Skip hook documentation (contains example patterns)
    if [[ "$file" == hooks/* ]] || [[ "$file" == *README* ]] || [[ "$file" == *EXAMPLE* ]]; then
        continue
    fi

    for pattern in "${PATTERNS[@]}"; do
        if grep -iE "$pattern" "$file" > /dev/null 2>&1; then
            echo -e "${RED}ERROR: Potential credential found in $file${NC}"
            echo -e "${YELLOW}Pattern matched: $pattern${NC}"
            grep -inE --color=always "$pattern" "$file" | head -3
            FAILED=1
        fi
    done
done

# =============================================================================
# CHECK 2: Detect credential file names
# =============================================================================
echo "Checking for credential file names..."

FORBIDDEN_FILES=(
    "*.pem"
    "*.key"
    "*credentials*.json"
    "*secrets*.json"
    "*token*.txt"
    "*_key.json"
    "id_rsa"
    "id_dsa"
    "id_ecdsa"
    "id_ed25519"
    ".env"
    ".env.local"
    "vault_token"
)

for file in $FILES; do
    filename=$(basename "$file")
    for pattern in "${FORBIDDEN_FILES[@]}"; do
        if [[ "$filename" == $pattern ]]; then
            echo -e "${RED}ERROR: Forbidden file type: $file${NC}"
            echo -e "${YELLOW}File matches pattern: $pattern${NC}"
            FAILED=1
        fi
    done
done

# =============================================================================
# CHECK 3: Detect credential directories
# =============================================================================
echo "Checking for credential directories..."

FORBIDDEN_DIRS=(
    "keys/"
    "key/"
    ".keys/"
    "secrets/"
    ".secrets/"
    "vault/"
    "certs/"
    "certificates/"
)

for file in $FILES; do
    for dir in "${FORBIDDEN_DIRS[@]}"; do
        if [[ "$file" == *"$dir"* ]]; then
            echo -e "${RED}ERROR: File in forbidden directory: $file${NC}"
            echo -e "${YELLOW}Directory: $dir${NC}"
            FAILED=1
        fi
    done
done

# =============================================================================
# CHECK 4: High entropy strings (potential secrets)
# =============================================================================
echo "Checking for high-entropy strings..."

for file in $FILES; do
    # Skip non-text files
    if [ ! -f "$file" ] || file "$file" | grep -q "executable\|binary"; then
        continue
    fi

    # Look for base64-like strings longer than 40 characters
    if grep -E "['\"][A-Za-z0-9+/=]{40,}['\"]" "$file" > /dev/null 2>&1; then
        # Exclude common false positives (test data, examples)
        if ! grep -E "test|example|dummy|placeholder|REPLACE_ME" "$file" > /dev/null 2>&1; then
            echo -e "${YELLOW}WARNING: High-entropy string found in $file${NC}"
            echo "Review this file manually for hardcoded secrets"
            # Don't fail on this, just warn
        fi
    fi
done

# =============================================================================
# RESULT
# =============================================================================

if [ $FAILED -ne 0 ]; then
    echo ""
    echo -e "${RED}╔════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║  COMMIT BLOCKED: Potential credentials detected       ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════╝${NC}"
    echo ""
    echo "To fix this:"
    echo "1. Remove the sensitive data from your files"
    echo "2. Use environment variables or Vault for secrets"
    echo "3. Add the file to .gitignore if it should never be committed"
    echo ""
    echo "To bypass this check (NOT recommended):"
    echo "  git commit --no-verify"
    echo ""
    exit 1
fi

echo -e "\033[0;32m✓ No credentials detected\033[0m"
exit 0
